<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opioid Tolerance Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 18px;
        }
        .key-findings {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 5px;
        }
        .key-findings h2 {
            margin-top: 0;
            color: #2c3e50;
        }
        .finding-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
        }
        .finding-icon {
            width: 24px;
            height: 24px;
            background-color: #3498db;
            border-radius: 50%;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .chart-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        .stat-value {
            font-size: 36px;
            font-weight: bold;
            color: #3498db;
            margin: 10px 0;
        }
        .stat-label {
            color: #7f8c8d;
            font-size: 14px;
        }
        .upload-section {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #fileInput {
            display: none;
        }
        .upload-button {
            background-color: #3498db;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .upload-button:hover {
            background-color: #2980b9;
        }
        .export-button {
            background-color: #27ae60;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin-left: 10px;
        }
        .export-button:hover {
            background-color: #229954;
        }
        .export-section {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
        }
        .error-message {
            color: #e74c3c;
            margin-top: 10px;
            display: none;
        }
        .loading {
            display: none;
            margin-top: 20px;
        }
        .methodology {
            background-color: #fef9e7;
            border-left: 4px solid #f39c12;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
        }
        .methodology h3 {
            margin-top: 0;
            color: #f39c12;
        }
        .data-table {
            overflow-x: auto;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .highlight {
            background-color: #fff3cd;
            font-weight: bold;
        }
        .significance-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 10px;
            font-weight: bold;
        }
        .significant {
            background-color: #27ae60;
            color: white;
        }
        .not-significant {
            background-color: #95a5a6;
            color: white;
        }
        .effect-negligible {
            background-color: #bdc3c7;
            color: white;
        }
        .effect-small {
            background-color: #f39c12;
            color: white;
        }
        .effect-medium {
            background-color: #e67e22;
            color: white;
        }
        .effect-large {
            background-color: #e74c3c;
            color: white;
        }
        .plotly-chart {
            width: 100%;
            height: 400px;
        }
        .hide-on-export {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Perioperative Opioid Usage Analysis</h1>
        <p class="subtitle">Comparing Opioid-Tolerant vs Opioid-Naive Patients in Joint Replacement Surgery</p>
        
        <div class="upload-section hide-on-export" id="uploadSection">
            <h2>Upload Your Data</h2>
            <p>Select your CSV file to analyze opioid usage patterns</p>
            <input type="file" id="fileInput" accept=".csv">
            <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                Choose CSV File
            </button>
            <div class="error-message" id="errorMessage"></div>
            <div class="loading" id="loadingIndicator">Processing data...</div>
        </div>

        <div class="export-section" id="exportSection">
            <h3>Export Results</h3>
            <p>Save this analysis as a standalone HTML file to share with colleagues</p>
            <button class="export-button" onclick="exportToHTML()">
                Export as HTML Report
            </button>
        </div>

        <div id="analysisResults" style="display: none;">
            <div class="key-findings">
                <h2>Key Findings</h2>
                <div id="keyFindingsContent"></div>
            </div>

            <div class="methodology">
                <h3>Methodology</h3>
                <p><strong>Opioid Tolerance Definition:</strong> Patients with preoperative oral morphine equivalent (OME) ≥10mg/day</p>
                <p><strong>Time Windows Analyzed:</strong></p>
                <ul>
                    <li>Intraoperative to 24 hours post-op</li>
                    <li>24-48 hours post-op</li>
                    <li>48-72 hours post-op</li>
                </ul>
                <p><strong>Statistical Analysis:</strong></p>
                <ul>
                    <li><strong>Primary Test:</strong> Mann-Whitney U test (non-parametric) for group comparisons</li>
                    <li><strong>Effect Size:</strong> Cohen's d with interpretation (0.2=small, 0.5=medium, 0.8=large)</li>
                    <li><strong>Confidence Intervals:</strong> 95% CI for mean differences</li>
                    <li><strong>Visualization:</strong> Interactive box plots and charts with hover details</li>
                </ul>
                <p><strong>Rationale:</strong> Mann-Whitney U test chosen over t-tests due to typically skewed distribution of opioid consumption data, providing more robust p-values.</p>
            </div>

            <div class="stats-grid" id="statsGrid"></div>

            <div class="chart-grid">
                <div class="chart-container">
                    <h3>Mean Opioid Consumption by Time Period</h3>
                    <div id="timeWindowChart" class="plotly-chart"></div>
                    <div style="background-color: #f8f9fa; padding: 15px; margin-top: 15px; border-radius: 5px; border-left: 3px solid #6c757d;">
                        <h4 style="margin-top: 0; color: #495057;">How to Interpret:</h4>
                        <p><strong>What it shows:</strong> Average opioid consumption for each 24-hour period comparing tolerant vs naive patients.</p>
                        <p><strong>Key insights:</strong> Higher bars indicate greater opioid requirements. Look for which group needs more medication and when the largest differences occur. This helps predict staffing needs and medication requirements for different time periods.</p>
                        <p><strong>Clinical relevance:</strong> Use this to plan post-operative pain management protocols and identify peak consumption periods requiring enhanced monitoring.</p>
                    </div>
                </div>
                <div class="chart-container">
                    <h3>Cumulative Opioid Usage Over 72 Hours</h3>
                    <div id="cumulativeChart" class="plotly-chart"></div>
                    <div style="background-color: #f8f9fa; padding: 15px; margin-top: 15px; border-radius: 5px; border-left: 3px solid #6c757d;">
                        <h4 style="margin-top: 0; color: #495057;">How to Interpret:</h4>
                        <p><strong>What it shows:</strong> Total accumulated opioid consumption from surgery through 72 hours post-operatively.</p>
                        <p><strong>Key insights:</strong> Steeper slopes indicate faster consumption rates. The gap between lines shows cumulative difference between groups. A widening gap suggests ongoing disparity in pain management needs.</p>
                        <p><strong>Clinical relevance:</strong> Helps estimate total medication requirements for discharge planning and identifies if differences persist or resolve over time.</p>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <h3>Distribution of Opioid Requirements</h3>
                <div id="distributionChart" class="plotly-chart"></div>
                <div style="background-color: #f8f9fa; padding: 15px; margin-top: 15px; border-radius: 5px; border-left: 3px solid #6c757d;">
                    <h4 style="margin-top: 0; color: #495057;">How to Interpret:</h4>
                    <p><strong>What it shows:</strong> Number of patients in each consumption range, grouped by tolerance status.</p>
                    <p><strong>Key insights:</strong> Compare the shapes of distributions. Look for where most patients cluster and identify outliers with very high consumption. Side-by-side bars make it easy to see differences between groups.</p>
                    <p><strong>Clinical relevance:</strong> Helps identify typical consumption ranges for stocking medications and planning resources. Shows if there are distinct subpopulations requiring different management approaches.</p>
                </div>
            </div>

            <div class="chart-container">
                <h3>Overlaid Histogram: Total 72-Hour Opioid Consumption</h3>
                <div id="overlaidHistogramChart" class="plotly-chart"></div>
                <div style="background-color: #f8f9fa; padding: 15px; margin-top: 15px; border-radius: 5px; border-left: 3px solid #6c757d;">
                    <h4 style="margin-top: 0; color: #495057;">How to Interpret:</h4>
                    <p><strong>What it shows:</strong> Probability density curves showing how opioid consumption is distributed across both patient groups.</p>
                    <p><strong>Key insights:</strong> Overlapping areas show similar consumption patterns, while separated areas indicate distinct differences. Higher peaks show more common consumption levels. The statistical summary box provides quantitative measures of group differences.</p>
                    <p><strong>Clinical relevance:</strong> Reveals whether groups are truly distinct populations or have significant overlap. Helps determine if tolerance-based protocols are justified and identifies patients who don't fit typical patterns.</p>
                </div>
            </div>

            <div class="chart-container">
                <h3>Correlation Analysis: Pre-op vs Post-op Opioid Consumption</h3>
                <div id="correlationChart" class="plotly-chart"></div>
                <div style="background-color: #f8f9fa; padding: 15px; margin-top: 15px; border-radius: 5px; border-left: 3px solid #6c757d;">
                    <h4 style="margin-top: 0; color: #495057;">How to Interpret:</h4>
                    <p><strong>What it shows:</strong> Relationship between pre-operative daily opioid use and total post-operative consumption, with predictive regression line.</p>
                    <p><strong>Key insights:</strong> Points closer to the regression line are more predictable. Scattered points suggest high individual variability. The correlation coefficient (r) indicates prediction strength: >0.7 = strong, 0.5-0.7 = moderate, 0.3-0.5 = weak, <0.3 = very weak.</p>
                    <p><strong>Clinical relevance:</strong> Use the regression equation to predict individual patient needs based on pre-operative consumption. Outliers (far from the line) may need special attention or investigation for underlying factors.</p>
                </div>
            </div>

            <div class="chart-container">
                <h3>ROC Curve: Predicting High Opioid Consumers</h3>
                <div id="rocChart" class="plotly-chart"></div>
                <div style="background-color: #f8f9fa; padding: 15px; margin-top: 15px; border-radius: 5px; border-left: 3px solid #6c757d;">
                    <h4 style="margin-top: 0; color: #495057;">How to Interpret:</h4>
                    <p><strong>What it shows:</strong> How well pre-operative OME predicts which patients will be "high consumers" (>75th percentile of post-op consumption).</p>
                    <p><strong>Key insights:</strong> The curve closer to the upper-left corner indicates better prediction. AUC of 0.5 = random guessing, 1.0 = perfect prediction. The optimal threshold (star) balances sensitivity and specificity better than the current 10mg threshold (diamond).</p>
                    <p><strong>Clinical relevance:</strong> Determines if pre-operative screening can identify patients needing enhanced pain management protocols. Compare optimal vs current thresholds to potentially improve patient selection criteria.</p>
                </div>
            </div>

            <div class="chart-container">
                <h3>Box Plot: Opioid Consumption by Group and Time Period</h3>
                <div id="boxPlotChart" class="plotly-chart"></div>
                <div style="background-color: #f8f9fa; padding: 15px; margin-top: 15px; border-radius: 5px; border-left: 3px solid #6c757d;">
                    <h4 style="margin-top: 0; color: #495057;">How to Interpret:</h4>
                    <p><strong>What it shows:</strong> Statistical distribution summary for each group and time period. Box shows middle 50% of patients, line in box is median, whiskers show normal range, dots are outliers.</p>
                    <p><strong>Key insights:</strong> Compare box positions (medians), box heights (variability), and outlier patterns. Overlapping boxes suggest similar consumption, while separated boxes indicate distinct groups.</p>
                    <p><strong>Clinical relevance:</strong> Identify typical patients (within boxes) vs exceptional cases (outliers). Use median values for clinical planning and outlier patterns to develop protocols for complex cases.</p>
                </div>
            </div>

            <div class="data-table">
                <h3>Summary Statistics by Patient Group</h3>
                <table id="summaryTable">
                    <thead>
                        <tr>
                            <th>Time Period</th>
                            <th>Opioid-Naive<br>Mean OME (SD)</th>
                            <th>Opioid-Tolerant<br>Mean OME (SD)</th>
                            <th>Difference<br>[95% CI]</th>
                            <th>Cohen's d<br>(Effect Size)</th>
                            <th>P-value<br>(Mann-Whitney U)</th>
                        </tr>
                    </thead>
                    <tbody id="summaryTableBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let globalData = null;
        let globalProcessedData = null;
        
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('errorMessage').style.display = 'none';
                
                Papa.parse(file, {
                    complete: function(results) {
                        try {
                            processData(results.data);
                            document.getElementById('loadingIndicator').style.display = 'none';
                            document.getElementById('analysisResults').style.display = 'block';
                            document.getElementById('exportSection').style.display = 'block';
                        } catch (error) {
                            showError('Error processing data: ' + error.message);
                        }
                    },
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true
                });
            }
        });

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorMessage').style.display = 'block';
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        function processData(data) {
            globalData = data;
            
            // Process and categorize patients
            const processedData = data.map(row => {
                const preOpOME = parseFloat(row['oral morphine equivalent (mg)']) || 0;
                const ome0_24 = parseFloat(row['Oral morphine equivalents (0-24h post-op)']) || 0;
                const ome24_48 = parseFloat(row['Oral morphine equivalents (24-48h post op)']) || 0;
                const ome48_72 = parseFloat(row['Total morphine equivalents (48-72h post-op)']) || 0;
                
                return {
                    patientId: row['Patient URN'],
                    preOpOME: preOpOME,
                    isOpioidTolerant: preOpOME >= 10,
                    ome0_24: ome0_24,
                    ome24_48: ome24_48,
                    ome48_72: ome48_72,
                    totalOME: ome0_24 + ome24_48 + ome48_72
                };
            }).filter(row => !isNaN(row.totalOME));

            globalProcessedData = processedData;

            // Calculate statistics
            const tolerantPatients = processedData.filter(p => p.isOpioidTolerant);
            const naivePatients = processedData.filter(p => !p.isOpioidTolerant);

            // Update key findings
            updateKeyFindings(tolerantPatients, naivePatients);
            
            // Update statistics cards
            updateStatsCards(tolerantPatients, naivePatients);
            
            // Create charts
            createTimeWindowChart(tolerantPatients, naivePatients);
            createCumulativeChart(tolerantPatients, naivePatients);
            createDistributionChart(tolerantPatients, naivePatients);
            createOverlaidHistogramChart(tolerantPatients, naivePatients);
            createCorrelationChart(tolerantPatients, naivePatients);
            createROCChart(tolerantPatients, naivePatients);
            createBoxPlotChart(tolerantPatients, naivePatients);
            
            // Update summary table
            updateSummaryTable(tolerantPatients, naivePatients);
        }

        function exportToHTML() {
            // Get current HTML content
            const currentHTML = document.documentElement.outerHTML;
            
            // Create a new document
            const parser = new DOMParser();
            const doc = parser.parseFromString(currentHTML, 'text/html');
            
            // Remove upload section and export button
            const uploadSection = doc.getElementById('uploadSection');
            if (uploadSection) uploadSection.remove();
            
            const exportSection = doc.getElementById('exportSection');
            if (exportSection) exportSection.remove();
            
            // Add embedded data script
            const dataScript = doc.createElement('script');
            dataScript.textContent = `
                window.embeddedData = ${JSON.stringify(globalProcessedData)};
                window.addEventListener('load', function() {
                    if (window.embeddedData) {
                        const tolerantPatients = window.embeddedData.filter(p => p.isOpioidTolerant);
                        const naivePatients = window.embeddedData.filter(p => !p.isOpioidTolerant);
                        
                        updateKeyFindings(tolerantPatients, naivePatients);
                        updateStatsCards(tolerantPatients, naivePatients);
                        createTimeWindowChart(tolerantPatients, naivePatients);
                        createCumulativeChart(tolerantPatients, naivePatients);
                        createDistributionChart(tolerantPatients, naivePatients);
                        createOverlaidHistogramChart(tolerantPatients, naivePatients);
                        createCorrelationChart(tolerantPatients, naivePatients);
                        createROCChart(tolerantPatients, naivePatients);
                        createBoxPlotChart(tolerantPatients, naivePatients);
                        updateSummaryTable(tolerantPatients, naivePatients);
                        
                        document.getElementById('analysisResults').style.display = 'block';
                    }
                });
            `;
            doc.body.appendChild(dataScript);
            
            // Get the final HTML
            const exportedHTML = doc.documentElement.outerHTML;
            
            // Create download
            const blob = new Blob([exportedHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `opioid-tolerance-analysis-${new Date().toISOString().split('T')[0]}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function calculateStats(data, field) {
            const values = data.map(d => d[field]).filter(v => !isNaN(v));
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const sd = Math.sqrt(values.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / (values.length - 1));
            return { mean: mean || 0, sd: sd || 0, n: values.length, values: values };
        }

        function calculateMannWhitneyU(group1Values, group2Values) {
            // Mann-Whitney U test (non-parametric)
            const n1 = group1Values.length;
            const n2 = group2Values.length;
            
            if (n1 === 0 || n2 === 0) return { U: 0, p: 1, z: 0 };
            
            // Combine and rank all values
            const combined = [...group1Values.map(v => ({value: v, group: 1})), 
                             ...group2Values.map(v => ({value: v, group: 2}))];
            combined.sort((a, b) => a.value - b.value);
            
            // Assign ranks (handle ties by averaging ranks)
            let ranks = [];
            let i = 0;
            while (i < combined.length) {
                let j = i;
                let sum = 0;
                let count = 0;
                
                // Find all values equal to current value
                while (j < combined.length && combined[j].value === combined[i].value) {
                    sum += (j + 1); // ranks are 1-indexed
                    count++;
                    j++;
                }
                
                // Assign average rank to all tied values
                const avgRank = sum / count;
                for (let k = i; k < j; k++) {
                    ranks.push(avgRank);
                }
                i = j;
            }
            
            // Calculate rank sums
            let R1 = 0;
            for (let k = 0; k < combined.length; k++) {
                if (combined[k].group === 1) {
                    R1 += ranks[k];
                }
            }
            
            // Calculate U statistics
            const U1 = R1 - (n1 * (n1 + 1)) / 2;
            const U2 = (n1 * n2) - U1;
            const U = Math.min(U1, U2);
            
            // Calculate z-score for large samples
            const meanU = (n1 * n2) / 2;
            const sdU = Math.sqrt((n1 * n2 * (n1 + n2 + 1)) / 12);
            const z = Math.abs((U - meanU) / sdU);
            
            // Two-tailed p-value
            const p = 2 * (1 - normalCDF(z));
            
            return { U: U, p: p, z: z };
        }

        function calculateCohenD(group1, group2) {
            // Cohen's d effect size
            const n1 = group1.n;
            const n2 = group2.n;
            const mean1 = group1.mean;
            const mean2 = group2.mean;
            const sd1 = group1.sd;
            const sd2 = group2.sd;
            
            if (n1 < 2 || n2 < 2) return 0;
            
            // Pooled standard deviation
            const pooledSD = Math.sqrt(((n1 - 1) * sd1 * sd1 + (n2 - 1) * sd2 * sd2) / (n1 + n2 - 2));
            
            if (pooledSD === 0) return 0;
            
            const d = (mean1 - mean2) / pooledSD;
            return Math.abs(d); // Return absolute value for magnitude
        }

        function calculateConfidenceInterval(group1, group2, confidence = 0.95) {
            // 95% CI for difference in means
            const n1 = group1.n;
            const n2 = group2.n;
            const mean1 = group1.mean;
            const mean2 = group2.mean;
            const sd1 = group1.sd;
            const sd2 = group2.sd;
            
            if (n1 < 2 || n2 < 2) return { lower: 0, upper: 0 };
            
            const diff = mean1 - mean2;
            const se = Math.sqrt((sd1 * sd1 / n1) + (sd2 * sd2 / n2));
            
            // Use t-distribution critical value (approximated as 1.96 for large samples)
            const tCritical = 1.96; // For 95% CI, could be more precise with df
            
            const margin = tCritical * se;
            
            return {
                lower: diff - margin,
                upper: diff + margin
            };
        }

        function interpretCohenD(d) {
            if (d < 0.2) return "Negligible";
            if (d < 0.5) return "Small";
            if (d < 0.8) return "Medium";
            return "Large";
        }

        function normalCDF(x) {
            // Approximation of the cumulative distribution function for standard normal
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x) / Math.sqrt(2);
            
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return 0.5 * (1.0 + sign * y);
        }

        function updateKeyFindings(tolerant, naive) {
            const tolerantTotal = calculateStats(tolerant, 'totalOME');
            const naiveTotal = calculateStats(naive, 'totalOME');
            const foldIncrease = tolerantTotal.mean / naiveTotal.mean;
            const mannWhitney = calculateMannWhitneyU(tolerantTotal.values, naiveTotal.values);
            const cohenD = calculateCohenD(tolerantTotal, naiveTotal);
            const effectSizeText = interpretCohenD(cohenD);
            
            // Calculate correlation for predictive insights
            const allPatients = [...tolerant, ...naive];
            const correlation = calculateLinearRegression(
                allPatients.map(p => p.preOpOME), 
                allPatients.map(p => p.totalOME)
            );
            
            // Check significance for all time periods using Mann-Whitney U
            const periods = ['ome0_24', 'ome24_48', 'ome48_72'];
            let allSignificant = true;
            let maxEffectSize = 0;
            let maxEffectPeriod = '';
            
            periods.forEach(period => {
                const tStats = calculateStats(tolerant, period);
                const nStats = calculateStats(naive, period);
                const test = calculateMannWhitneyU(tStats.values, nStats.values);
                const d = calculateCohenD(tStats, nStats);
                
                if (test.p >= 0.05) allSignificant = false;
                if (d > maxEffectSize) {
                    maxEffectSize = d;
                    maxEffectPeriod = period === 'ome0_24' ? '0-24 hours' : 
                                   period === 'ome24_48' ? '24-48 hours' : '48-72 hours';
                }
            });

            const correlationStrength = Math.abs(correlation.correlation) > 0.7 ? 'strong' : 
                                       Math.abs(correlation.correlation) > 0.5 ? 'moderate' : 
                                       Math.abs(correlation.correlation) > 0.3 ? 'weak' : 'very weak';

            const findings = [
                `Opioid-tolerant patients (n=${tolerant.length}) required ${foldIncrease.toFixed(1)}x more opioids overall`,
                `Mean 72-hour consumption: ${tolerantTotal.mean.toFixed(1)} mg vs ${naiveTotal.mean.toFixed(1)} mg OME (p${mannWhitney.p < 0.001 ? '<0.001' : '=' + mannWhitney.p.toFixed(3)})`,
                `Effect size: Cohen's d = ${cohenD.toFixed(2)} (${effectSizeText} clinical difference)`,
                `Pre-op to post-op correlation: r = ${correlation.correlation.toFixed(3)} (${correlationStrength} predictive relationship)`,
                `${((tolerant.length / (tolerant.length + naive.length)) * 100).toFixed(1)}% of patients were opioid-tolerant preoperatively`,
                allSignificant ? `All time periods showed statistically significant differences with ${interpretCohenD(maxEffectSize).toLowerCase()} to large effect sizes` : 
                                `Largest effect size in ${maxEffectPeriod} period (d=${maxEffectSize.toFixed(2)})`
            ];

            const findingsHtml = findings.map(f => 
                `<div class="finding-item">
                    <div class="finding-icon">✓</div>
                    <span>${f}</span>
                </div>`
            ).join('');
            
            document.getElementById('keyFindingsContent').innerHTML = findingsHtml;
        }

        function updateStatsCards(tolerant, naive) {
            const totalPatients = tolerant.length + naive.length;
            const tolerantPercent = (tolerant.length / totalPatients * 100).toFixed(1);
            
            const tolerantMean = calculateStats(tolerant, 'totalOME').mean;
            const naiveMean = calculateStats(naive, 'totalOME').mean;
            
            const statsHtml = `
                <div class="stat-card">
                    <div class="stat-label">Total Patients</div>
                    <div class="stat-value">${totalPatients}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Opioid-Tolerant</div>
                    <div class="stat-value">${tolerant.length}</div>
                    <div class="stat-label">(${tolerantPercent}%)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Mean 72h OME (Tolerant)</div>
                    <div class="stat-value">${tolerantMean.toFixed(1)}</div>
                    <div class="stat-label">mg</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Mean 72h OME (Naive)</div>
                    <div class="stat-value">${naiveMean.toFixed(1)}</div>
                    <div class="stat-label">mg</div>
                </div>
            `;
            
            document.getElementById('statsGrid').innerHTML = statsHtml;
        }

        function createTimeWindowChart(tolerant, naive) {
            const periods = ['0-24 hours', '24-48 hours', '48-72 hours'];
            const tolerantMeans = [
                calculateStats(tolerant, 'ome0_24').mean,
                calculateStats(tolerant, 'ome24_48').mean,
                calculateStats(tolerant, 'ome48_72').mean
            ];
            const naiveMeans = [
                calculateStats(naive, 'ome0_24').mean,
                calculateStats(naive, 'ome24_48').mean,
                calculateStats(naive, 'ome48_72').mean
            ];

            const trace1 = {
                x: periods,
                y: tolerantMeans,
                name: 'Opioid-Tolerant',
                type: 'bar',
                marker: { color: '#e74c3c' },
                hovertemplate: '%{y:.1f} mg<extra></extra>'
            };

            const trace2 = {
                x: periods,
                y: naiveMeans,
                name: 'Opioid-Naive',
                type: 'bar',
                marker: { color: '#3498db' },
                hovertemplate: '%{y:.1f} mg<extra></extra>'
            };

            const layout = {
                title: false,
                xaxis: { title: 'Time Period' },
                yaxis: { title: 'Mean OME (mg)' },
                showlegend: true,
                margin: { t: 40, b: 80, l: 60, r: 40 },
                font: { family: 'Arial, sans-serif', size: 12 }
            };

            Plotly.newPlot('timeWindowChart', [trace1, trace2], layout, {responsive: true});
        }

        function createCumulativeChart(tolerant, naive) {
            const tolerantCumulative = [
                calculateStats(tolerant, 'ome0_24').mean,
                calculateStats(tolerant, 'ome0_24').mean + calculateStats(tolerant, 'ome24_48').mean,
                calculateStats(tolerant, 'totalOME').mean
            ];
            const naiveCumulative = [
                calculateStats(naive, 'ome0_24').mean,
                calculateStats(naive, 'ome0_24').mean + calculateStats(naive, 'ome24_48').mean,
                calculateStats(naive, 'totalOME').mean
            ];

            const trace1 = {
                x: ['24 hours', '48 hours', '72 hours'],
                y: tolerantCumulative,
                name: 'Opioid-Tolerant',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#e74c3c', width: 3 },
                marker: { size: 8 },
                hovertemplate: '%{y:.1f} mg<extra></extra>'
            };

            const trace2 = {
                x: ['24 hours', '48 hours', '72 hours'],
                y: naiveCumulative,
                name: 'Opioid-Naive',
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#3498db', width: 3 },
                marker: { size: 8 },
                hovertemplate: '%{y:.1f} mg<extra></extra>'
            };

            const layout = {
                title: false,
                xaxis: { title: 'Time Point' },
                yaxis: { title: 'Cumulative OME (mg)' },
                showlegend: true,
                margin: { t: 40, b: 80, l: 60, r: 40 },
                font: { family: 'Arial, sans-serif', size: 12 }
            };

            Plotly.newPlot('cumulativeChart', [trace1, trace2], layout, {responsive: true});
        }

        function createDistributionChart(tolerant, naive) {
            const bins = [0, 50, 100, 150, 200, 250, 300, 350, 400];
            const tolerantDist = createDistribution(tolerant.map(p => p.totalOME), bins);
            const naiveDist = createDistribution(naive.map(p => p.totalOME), bins);
            const binLabels = bins.slice(0, -1).map((b, i) => `${b}-${bins[i+1]}`);

            const trace1 = {
                x: binLabels,
                y: tolerantDist,
                name: 'Opioid-Tolerant',
                type: 'bar',
                marker: { color: '#e74c3c', opacity: 0.7 },
                hovertemplate: '%{y} patients<extra></extra>'
            };

            const trace2 = {
                x: binLabels,
                y: naiveDist,
                name: 'Opioid-Naive',
                type: 'bar',
                marker: { color: '#3498db', opacity: 0.7 },
                hovertemplate: '%{y} patients<extra></extra>'
            };

            const layout = {
                title: false,
                xaxis: { title: 'Total 72-hour OME (mg)' },
                yaxis: { title: 'Number of Patients' },
                barmode: 'group',
                showlegend: true,
                margin: { t: 40, b: 80, l: 60, r: 40 },
                font: { family: 'Arial, sans-serif', size: 12 }
            };

            Plotly.newPlot('distributionChart', [trace1, trace2], layout, {responsive: true});
        }

        function createDistribution(values, bins) {
            const dist = new Array(bins.length - 1).fill(0);
            values.forEach(v => {
                for (let i = 0; i < bins.length - 1; i++) {
                    if (v >= bins[i] && v < bins[i + 1]) {
                        dist[i]++;
                        break;
                    }
                }
            });
            return dist;
        }

        function createOverlaidHistogramChart(tolerant, naive) {
            // Extract total OME values
            const tolerantValues = tolerant.map(p => p.totalOME);
            const naiveValues = naive.map(p => p.totalOME);
            
            // Calculate statistics for display
            const tolerantStats = calculateStats(tolerant, 'totalOME');
            const naiveStats = calculateStats(naive, 'totalOME');
            const mannWhitney = calculateMannWhitneyU(tolerantStats.values, naiveStats.values);
            const cohenD = calculateCohenD(tolerantStats, naiveStats);
            
            const trace1 = {
                x: tolerantValues,
                name: `Opioid-Tolerant (n=${tolerant.length})`,
                type: 'histogram',
                opacity: 0.7,
                marker: { 
                    color: '#e74c3c',
                    line: { color: '#c0392b', width: 1 }
                },
                autobinx: true,
                histnorm: 'probability density',
                hovertemplate: 'Range: %{x}<br>Density: %{y:.3f}<br>Count: %{text}<extra></extra>',
                text: tolerantValues
            };

            const trace2 = {
                x: naiveValues,
                name: `Opioid-Naive (n=${naive.length})`,
                type: 'histogram',
                opacity: 0.7,
                marker: { 
                    color: '#3498db',
                    line: { color: '#2980b9', width: 1 }
                },
                autobinx: true,
                histnorm: 'probability density',
                hovertemplate: 'Range: %{x}<br>Density: %{y:.3f}<br>Count: %{text}<extra></extra>',
                text: naiveValues
            };

            const layout = {
                title: false,
                xaxis: { 
                    title: 'Total 72-hour OME (mg)',
                    showgrid: true,
                    gridcolor: '#f0f0f0'
                },
                yaxis: { 
                    title: 'Probability Density',
                    showgrid: true,
                    gridcolor: '#f0f0f0'
                },
                barmode: 'overlay',
                showlegend: true,
                legend: {
                    x: 0.7,
                    y: 0.95,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ddd',
                    borderwidth: 1
                },
                margin: { t: 40, b: 80, l: 80, r: 40 },
                font: { family: 'Arial, sans-serif', size: 12 },
                annotations: [{
                    x: 0.02,
                    y: 0.98,
                    xref: 'paper',
                    yref: 'paper',
                    text: `<b>Statistical Summary:</b><br>` +
                          `Mean Difference: +${(tolerantStats.mean - naiveStats.mean).toFixed(1)} mg<br>` +
                          `Cohen's d: ${cohenD.toFixed(2)} (${interpretCohenD(cohenD)})<br>` +
                          `p-value: ${mannWhitney.p < 0.001 ? '<0.001' : mannWhitney.p.toFixed(3)}`,
                    showarrow: false,
                    align: 'left',
                    bgcolor: 'rgba(255,255,255,0.9)',
                    bordercolor: '#ddd',
                    borderwidth: 1,
                    font: { size: 10 }
                }]
            };

            Plotly.newPlot('overlaidHistogramChart', [trace1, trace2], layout, {responsive: true});
        }

        function calculateLinearRegression(xValues, yValues) {
            const n = xValues.length;
            if (n === 0) return { slope: 0, intercept: 0, r2: 0, correlation: 0 };
            
            const sumX = xValues.reduce((a, b) => a + b, 0);
            const sumY = yValues.reduce((a, b) => a + b, 0);
            const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
            const sumXX = xValues.reduce((sum, x) => sum + x * x, 0);
            const sumYY = yValues.reduce((sum, y) => sum + y * y, 0);
            
            const meanX = sumX / n;
            const meanY = sumY / n;
            
            // Calculate slope and intercept
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = meanY - slope * meanX;
            
            // Calculate correlation coefficient
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
            const correlation = denominator === 0 ? 0 : numerator / denominator;
            
            // Calculate R²
            const r2 = correlation * correlation;
            
            return { slope, intercept, r2, correlation };
        }

        function createCorrelationChart(tolerant, naive) {
            // Combine all patients for overall analysis
            const allPatients = [...tolerant, ...naive];
            
            // Extract data for correlation
            const preOpValues = allPatients.map(p => p.preOpOME);
            const totalOMEValues = allPatients.map(p => p.totalOME);
            
            // Calculate regression for all patients
            const regression = calculateLinearRegression(preOpValues, totalOMEValues);
            
            // Calculate separate correlations for each group
            const tolerantRegression = calculateLinearRegression(
                tolerant.map(p => p.preOpOME), 
                tolerant.map(p => p.totalOME)
            );
            const naiveRegression = calculateLinearRegression(
                naive.map(p => p.preOpOME), 
                naive.map(p => p.totalOME)
            );
            
            // Create regression line data
            const minX = Math.min(...preOpValues);
            const maxX = Math.max(...preOpValues);
            const regressionX = [minX, maxX];
            const regressionY = regressionX.map(x => regression.slope * x + regression.intercept);
            
            // Scatter plot for tolerant patients
            const tolerantTrace = {
                x: tolerant.map(p => p.preOpOME),
                y: tolerant.map(p => p.totalOME),
                mode: 'markers',
                type: 'scatter',
                name: `Opioid-Tolerant (n=${tolerant.length})`,
                marker: {
                    color: '#e74c3c',
                    size: 8,
                    opacity: 0.7,
                    line: { color: '#c0392b', width: 1 }
                },
                hovertemplate: 'Pre-op OME: %{x:.1f} mg<br>Total 72h OME: %{y:.1f} mg<extra></extra>'
            };
            
            // Scatter plot for naive patients
            const naiveTrace = {
                x: naive.map(p => p.preOpOME),
                y: naive.map(p => p.totalOME),
                mode: 'markers',
                type: 'scatter',
                name: `Opioid-Naive (n=${naive.length})`,
                marker: {
                    color: '#3498db',
                    size: 8,
                    opacity: 0.7,
                    line: { color: '#2980b9', width: 1 }
                },
                hovertemplate: 'Pre-op OME: %{x:.1f} mg<br>Total 72h OME: %{y:.1f} mg<extra></extra>'
            };
            
            // Regression line
            const regressionTrace = {
                x: regressionX,
                y: regressionY,
                mode: 'lines',
                type: 'scatter',
                name: 'Regression Line',
                line: {
                    color: '#2c3e50',
                    width: 3,
                    dash: 'dash'
                },
                hovertemplate: 'Predicted: %{y:.1f} mg<extra></extra>'
            };
            
            // Identify outliers (residuals > 2 standard deviations)
            const residuals = allPatients.map(p => {
                const predicted = regression.slope * p.preOpOME + regression.intercept;
                return p.totalOME - predicted;
            });
            const residualMean = residuals.reduce((a, b) => a + b, 0) / residuals.length;
            const residualSD = Math.sqrt(residuals.reduce((sum, r) => sum + Math.pow(r - residualMean, 2), 0) / (residuals.length - 1));
            const outlierThreshold = 2 * residualSD;
            
            const outliers = allPatients.filter((p, i) => Math.abs(residuals[i]) > outlierThreshold);
            
            const layout = {
                title: false,
                xaxis: { 
                    title: 'Pre-operative OME (mg/day)',
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    zeroline: false
                },
                yaxis: { 
                    title: 'Total 72-hour Post-operative OME (mg)',
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    zeroline: false
                },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ddd',
                    borderwidth: 1
                },
                margin: { t: 40, b: 80, l: 80, r: 40 },
                font: { family: 'Arial, sans-serif', size: 12 },
                annotations: [
                    {
                        x: 0.98,
                        y: 0.35,
                        xref: 'paper',
                        yref: 'paper',
                        text: `<b>Overall Correlation:</b><br>` +
                              `r = ${regression.correlation.toFixed(3)}<br>` +
                              `R² = ${regression.r2.toFixed(3)}<br>` +
                              `<br><b>Group Correlations:</b><br>` +
                              `Tolerant: r = ${tolerantRegression.correlation.toFixed(3)}<br>` +
                              `Naive: r = ${naiveRegression.correlation.toFixed(3)}<br>` +
                              `<br><b>Outliers:</b> ${outliers.length} patients<br>` +
                              `(>2 SD from regression line)`,
                        showarrow: false,
                        align: 'left',
                        bgcolor: 'rgba(255,255,255,0.9)',
                        bordercolor: '#ddd',
                        borderwidth: 1,
                        font: { size: 11 }
                    },
                    {
                        x: 0.5,
                        y: 0.02,
                        xref: 'paper',
                        yref: 'paper',
                        text: `<b>Regression Equation:</b> Post-op OME = ${regression.slope.toFixed(2)} × Pre-op OME + ${regression.intercept.toFixed(1)}`,
                        showarrow: false,
                        align: 'center',
                        bgcolor: 'rgba(255,255,255,0.9)',
                        bordercolor: '#ddd',
                        borderwidth: 1,
                        font: { size: 11 }
                    }
                ]
            };

            Plotly.newPlot('correlationChart', [tolerantTrace, naiveTrace, regressionTrace], layout, {responsive: true});
        }

        function calculateROCCurve(predictorValues, outcomeValues, thresholds) {
            // Calculate sensitivity and specificity for each threshold
            const rocPoints = thresholds.map(threshold => {
                let tp = 0, fp = 0, tn = 0, fn = 0;
                
                for (let i = 0; i < predictorValues.length; i++) {
                    const predicted = predictorValues[i] >= threshold;
                    const actual = outcomeValues[i];
                    
                    if (predicted && actual) tp++;
                    else if (predicted && !actual) fp++;
                    else if (!predicted && !actual) tn++;
                    else fn++;
                }
                
                const sensitivity = tp + fn > 0 ? tp / (tp + fn) : 0;
                const specificity = tn + fp > 0 ? tn / (tn + fp) : 0;
                const fpr = 1 - specificity; // False Positive Rate
                
                return {
                    threshold,
                    sensitivity,
                    specificity,
                    fpr,
                    tp, fp, tn, fn,
                    youden: sensitivity + specificity - 1 // Youden's J statistic
                };
            });
            
            return rocPoints;
        }

        function calculateAUC(rocPoints) {
            // Calculate Area Under Curve using trapezoidal rule
            rocPoints.sort((a, b) => a.fpr - b.fpr);
            let auc = 0;
            
            for (let i = 1; i < rocPoints.length; i++) {
                const deltaX = rocPoints[i].fpr - rocPoints[i-1].fpr;
                const avgY = (rocPoints[i].sensitivity + rocPoints[i-1].sensitivity) / 2;
                auc += deltaX * avgY;
            }
            
            return Math.max(0, Math.min(1, auc));
        }

        function createROCChart(tolerant, naive) {
            const allPatients = [...tolerant, ...naive];
            
            // Define high consumers as >75th percentile
            const totalOMEValues = allPatients.map(p => p.totalOME).sort((a, b) => a - b);
            const percentile75 = totalOMEValues[Math.floor(totalOMEValues.length * 0.75)];
            
            // Create outcome variable (high consumer = true)
            const isHighConsumer = allPatients.map(p => p.totalOME > percentile75);
            const preOpOME = allPatients.map(p => p.preOpOME);
            
            // Generate thresholds from 0 to max preop OME
            const maxPreOpOME = Math.max(...preOpOME);
            const thresholds = [];
            for (let i = 0; i <= maxPreOpOME + 5; i += 0.5) {
                thresholds.push(i);
            }
            
            // Calculate ROC curve
            const rocPoints = calculateROCCurve(preOpOME, isHighConsumer, thresholds);
            const auc = calculateAUC(rocPoints);
            
            // Find optimal threshold (highest Youden's index)
            const optimalPoint = rocPoints.reduce((best, current) => 
                current.youden > best.youden ? current : best
            );
            
            // Find performance at current 10mg threshold
            const current10mgPoint = rocPoints.find(p => Math.abs(p.threshold - 10) < 0.5) || 
                                   rocPoints.reduce((closest, current) => 
                                       Math.abs(current.threshold - 10) < Math.abs(closest.threshold - 10) ? current : closest
                                   );
            
            // ROC Curve trace
            const rocTrace = {
                x: rocPoints.map(p => p.fpr),
                y: rocPoints.map(p => p.sensitivity),
                mode: 'lines',
                type: 'scatter',
                name: 'ROC Curve',
                line: { color: '#3498db', width: 3 },
                hovertemplate: 'FPR: %{x:.3f}<br>Sensitivity: %{y:.3f}<br>Threshold: %{text} mg<extra></extra>',
                text: rocPoints.map(p => p.threshold.toFixed(1))
            };
            
            // Diagonal reference line
            const diagonalTrace = {
                x: [0, 1],
                y: [0, 1],
                mode: 'lines',
                type: 'scatter',
                name: 'Random Classifier',
                line: { color: '#95a5a6', width: 2, dash: 'dash' },
                hoverinfo: 'skip'
            };
            
            // Optimal threshold point
            const optimalTrace = {
                x: [optimalPoint.fpr],
                y: [optimalPoint.sensitivity],
                mode: 'markers',
                type: 'scatter',
                name: `Optimal Threshold (${optimalPoint.threshold.toFixed(1)} mg)`,
                marker: { 
                    color: '#e74c3c', 
                    size: 12,
                    symbol: 'star',
                    line: { color: '#c0392b', width: 2 }
                },
                hovertemplate: `<b>Optimal Threshold</b><br>` +
                              `Threshold: ${optimalPoint.threshold.toFixed(1)} mg<br>` +
                              `Sensitivity: ${(optimalPoint.sensitivity * 100).toFixed(1)}%<br>` +
                              `Specificity: ${(optimalPoint.specificity * 100).toFixed(1)}%<br>` +
                              `Youden's J: ${optimalPoint.youden.toFixed(3)}<extra></extra>`
            };
            
            // Current 10mg threshold point
            const current10mgTrace = {
                x: [current10mgPoint.fpr],
                y: [current10mgPoint.sensitivity],
                mode: 'markers',
                type: 'scatter',
                name: 'Current 10mg Threshold',
                marker: { 
                    color: '#f39c12', 
                    size: 10,
                    symbol: 'diamond',
                    line: { color: '#d68910', width: 2 }
                },
                hovertemplate: `<b>Current 10mg Threshold</b><br>` +
                              `Threshold: ${current10mgPoint.threshold.toFixed(1)} mg<br>` +
                              `Sensitivity: ${(current10mgPoint.sensitivity * 100).toFixed(1)}%<br>` +
                              `Specificity: ${(current10mgPoint.specificity * 100).toFixed(1)}%<br>` +
                              `Youden's J: ${current10mgPoint.youden.toFixed(3)}<extra></extra>`
            };
            
            const layout = {
                title: false,
                xaxis: { 
                    title: 'False Positive Rate (1 - Specificity)',
                    range: [0, 1],
                    showgrid: true,
                    gridcolor: '#f0f0f0'
                },
                yaxis: { 
                    title: 'True Positive Rate (Sensitivity)',
                    range: [0, 1],
                    showgrid: true,
                    gridcolor: '#f0f0f0'
                },
                showlegend: true,
                legend: {
                    x: 0.6,
                    y: 0.2,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#ddd',
                    borderwidth: 1
                },
                margin: { t: 40, b: 80, l: 80, r: 40 },
                font: { family: 'Arial, sans-serif', size: 12 },
                annotations: [
                    {
                        x: 0.02,
                        y: 0.98,
                        xref: 'paper',
                        yref: 'paper',
                        text: `<b>ROC Analysis Results:</b><br>` +
                              `AUC = ${auc.toFixed(3)} (${auc > 0.9 ? 'Excellent' : auc > 0.8 ? 'Good' : auc > 0.7 ? 'Fair' : 'Poor'})<br>` +
                              `<br><b>High Consumer Definition:</b><br>` +
                              `>75th percentile (>${percentile75.toFixed(1)} mg)<br>` +
                              `${isHighConsumer.filter(x => x).length} of ${allPatients.length} patients<br>` +
                              `<br><b>Threshold Comparison:</b><br>` +
                              `Optimal: ${optimalPoint.threshold.toFixed(1)} mg<br>` +
                              `Current: 10.0 mg`,
                        showarrow: false,
                        align: 'left',
                        bgcolor: 'rgba(255,255,255,0.9)',
                        bordercolor: '#ddd',
                        borderwidth: 1,
                        font: { size: 11 }
                    }
                ]
            };

            Plotly.newPlot('rocChart', [rocTrace, diagonalTrace, optimalTrace, current10mgTrace], layout, {responsive: true});
        }

        function createBoxPlotChart(tolerant, naive) {
            const periods = [
                { name: '0-24h', field: 'ome0_24' },
                { name: '24-48h', field: 'ome24_48' },
                { name: '48-72h', field: 'ome48_72' }
            ];
            
            const traces = [];
            
            periods.forEach(period => {
                const tolerantStats = calculateStats(tolerant, period.field);
                const naiveStats = calculateStats(naive, period.field);
                
                // Naive group box plot
                traces.push({
                    y: naiveStats.values,
                    name: `${period.name} (Naive)`,
                    type: 'box',
                    marker: { color: '#3498db' },
                    boxpoints: 'outliers',
                    jitter: 0.3,
                    pointpos: -1.8,
                    hovertemplate: 'Value: %{y:.1f} mg<extra></extra>'
                });
                
                // Tolerant group box plot
                traces.push({
                    y: tolerantStats.values,
                    name: `${period.name} (Tolerant)`,
                    type: 'box',
                    marker: { color: '#e74c3c' },
                    boxpoints: 'outliers',
                    jitter: 0.3,
                    pointpos: -1.8,
                    hovertemplate: 'Value: %{y:.1f} mg<extra></extra>'
                });
            });

            const layout = {
                title: false,
                xaxis: { title: 'Time Period and Patient Group' },
                yaxis: { title: 'OME (mg)' },
                showlegend: true,
                margin: { t: 40, b: 120, l: 60, r: 40 },
                font: { family: 'Arial, sans-serif', size: 12 },
                boxmode: 'group'
            };

            Plotly.newPlot('boxPlotChart', traces, layout, {responsive: true});
        }

        function updateSummaryTable(tolerant, naive) {
            const periods = [
                { name: '0-24 hours', field: 'ome0_24' },
                { name: '24-48 hours', field: 'ome24_48' },
                { name: '48-72 hours', field: 'ome48_72' },
                { name: 'Total (0-72h)', field: 'totalOME' }
            ];

            const rows = periods.map(period => {
                const tolerantStats = calculateStats(tolerant, period.field);
                const naiveStats = calculateStats(naive, period.field);
                const diff = tolerantStats.mean - naiveStats.mean;
                
                // Calculate new statistics
                const mannWhitney = calculateMannWhitneyU(tolerantStats.values, naiveStats.values);
                const cohenD = calculateCohenD(tolerantStats, naiveStats);
                const ci = calculateConfidenceInterval(tolerantStats, naiveStats);
                const effectSizeInterpretation = interpretCohenD(cohenD);

                const isTotal = period.name === 'Total (0-72h)';
                const rowClass = isTotal ? ' class="highlight"' : '';
                
                const pValueText = mannWhitney.p < 0.001 ? '<0.001' : mannWhitney.p.toFixed(3);
                const significanceClass = mannWhitney.p < 0.05 ? 'significant' : 'not-significant';
                const significanceLabel = mannWhitney.p < 0.05 ? 'Significant' : 'Not significant';

                // Effect size badges
                const effectSizeClass = effectSizeInterpretation === 'Large' ? 'effect-large' :
                                       effectSizeInterpretation === 'Medium' ? 'effect-medium' :
                                       effectSizeInterpretation === 'Small' ? 'effect-small' : 'effect-negligible';

                return `
                    <tr${rowClass}>
                        <td>${period.name}</td>
                        <td>${naiveStats.mean.toFixed(1)} (${naiveStats.sd.toFixed(1)})</td>
                        <td>${tolerantStats.mean.toFixed(1)} (${tolerantStats.sd.toFixed(1)})</td>
                        <td>+${diff.toFixed(1)} mg<br><span style="font-size: 11px; color: #666;">[${ci.lower.toFixed(1)} to ${ci.upper.toFixed(1)}]</span></td>
                        <td>${cohenD.toFixed(2)} <span class="significance-badge ${effectSizeClass}">${effectSizeInterpretation}</span></td>
                        <td>${pValueText} <span class="significance-badge ${significanceClass}">${significanceLabel}</span></td>
                    </tr>
                `;
            }).join('');

            document.getElementById('summaryTableBody').innerHTML = rows;
        }

        // Initialize with sample data for demonstration
        window.addEventListener('load', function() {
            console.log('Ready to analyze opioid tolerance data with Plotly visualizations');
        });
    </script>
</body>
</html>
